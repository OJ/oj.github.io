<!DOCTYPE html>
<html>
   <head>
   <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>
    
    
    Webmachine, ErlyDTL and Riak - Part 3 - OJ&#39;s Perspective
    
  </title>
  <link rel="shortcut icon" href="/favicon.ico" />
  
     <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/bootstrap-theme.min.css">

  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/holder.min.js" type='text/javascript'></script>
  <link rel="stylesheet" href="/highlight/styles/github-gist.css">  
  <link rel="stylesheet" href="/css/style.css">

  <link rel="canonical" href="/posts/webmachine-erlydtl-and-riak-part-3/">
  
  <script src="/highlight/highlight.pack.js" type='text/javascript'></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.3.0/highlightjs-line-numbers.min.js"></script>
  <script type="text/javascript">

    $(document).ready(function() {
    
    hljs.initHighlightingOnLoad();
    $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
    hljs.lineNumbersBlock(block);
    });
});
  </script>
   </head>
   <body data-spy="scroll" data-target="#toc">
     <header class="navbar navbar-default navbar-fixed-top" id="top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">OJ&#39;s Perspective</a>
    </div>

    
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
	
	
	<li  ><a href="/">Home</a></li>
	
	

	

	

	

	

	

	

	

	
	
	<li > <a href="/streaming/" >Live Streaming</a></li>
	

	

	
	
	<li > <a href="/about/" >About</a></li>
	

	
	
	<li > <a href="/contact/" >Contact</a></li>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

      </ul>
</nav>
</header>

     <div class="jumbotron masthead" role="main">
       <div class="container">
	 <div class="row">

 	   <div class="col-md-8 col-md-offset-2 ">
	   
<div class="panel panel-default">
  <div class="panel-body">
      <article id='post' >
	<h1> Webmachine, ErlyDTL and Riak - Part 3 </h1>
	  
	  <span class="text-muted">Posted by:&nbsp;Wed Oct 13, 2010</span>

	  <p><img src="/uploads/2010/09/riak-logo.png" alt="Riak Logo" style="float:left;padding-right:5px;padding-bottom:5px;"/>For those of you who are new to the series, you may want to check out <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a> and <a href="/posts/webmachine-erlydtl-and-riak-part-2/" title="Webmachine, ErlyDTL and Riak - Part 2">Part 2</a> before reading this post. It will help give you some context as well as introduce you to some of the jargon and technology that I&rsquo;m using. If you&rsquo;ve already read then, or don&rsquo;t want to, then please read on!</p>

<p>This post builds on the previous two, but not without a few little modifications. If you&rsquo;re interested in following along step by step with your own version of the code running, then get yourself a copy of <a href="https://github.com/OJ/csd/tree/Part2-20110403" title="Source code for Part 2">this changeset</a> before doing so.</p>

<p>In this post we&rsquo;re going to cover:</p>

<ol>
<li>A slight refactor of code structure to support the &ldquo;standard&rdquo; approach to building applications in Erlang using OTP.</li>
<li>Building a small set of modules to talk to <a href="http://www.basho.com/developers.html#Riak" title="Riak">Riak</a>.</li>
<li>Creation of some <a href="http://json.org/" title="JavaScript Object Notation">JSON</a> helper functions for reading and writing data.</li>
<li>Calling all the way from the <a href="http://www.basho.com/developers.html#Webmachine" title="Webmachine">Webmachine</a> front-end to Riak to extract data and display it in a browser using <a href="http://github.com/evanmiller/erlydtl" title="ErlyDTL">ErlyDTL</a> templates.</li>
</ol>

<p>There are quite a few code snippets in this post as well as output from script executions and <code>bash</code> sessions. To avoid confusion, all file listings reference the path to the file that is being modified relative to the root of the project folder.</p>

<p>Be warned, this is a <em>long</em> post :) Get yourself a <em>shmoke und a pancake</em>, a glass of your favourite beverage and put some relaxing music on (instrumental is best).</p>

<p>Are you ready? OK, here we go &hellip;</p>

<h2 id="a-slight-refactor">A Slight Refactor</h2>

<p>I was ready to embark on this third post a while back but then I sat back and thought about how I might structure things if I were using another set of technologies. Usually I would put another layer between the web tier and the back-end database cluster as opposed to having the web tier talk to the database directly. It didn&rsquo;t make sense to me that this approach would be any different in Erlang.</p>

<p>I had a chat to <a href="http://twitter.com/sj_mackenzie" title="Stewart Mackenzie on Twitter">two</a> <a href="http://twitter.com/MatthewErbs" title="Matt Erbs on Twitter">blokes</a> that I really respect to get their views, and then I fired off a question to the Basho guys (via the <a href="irc://irc.freenode.com/riak" title="Riak IRC on Freenode">#riak IRC channel</a>). The Basho lads even made the effort to respond to me via the <a href="http://lists.basho.com/pipermail/riak-users_lists.basho.com/2010-September/001984.html" title="Riak Recap">Riak Recap</a> as they weren&rsquo;t available at the time to answer me via IRC (thanks again <a href="http://twitter.com/pharkmillups" title="Mark Phillips on Twitter">Mark</a>). All three of them confirmed my thoughts. Here&rsquo;s what appeared in the recap which captures the question and response nicely:</p>

<blockquote>
<p>Q &mdash; I have a Webmachine application which will be talking to Riak. I was going to put application and controller logic in that application and I am wondering if [I] should instead be creating a &ldquo;core&rdquo; OTP application with the business style logic in it and have the Webmachine app talk to that app which, in turn, talks to Riak? Is that the general approach that is taken [in Erlang applications]? (from TheColonial via #riak)</p>

<p>A &mdash; We recommend going with the latter approach. You&rsquo;re better off to create a core app that talks to Webmachine and Riak separately.</p>
</blockquote>

<p>Perfect, that makes total sense. Therefore the following describes what I did to modify the code base that I had in order to support this set up. <strong>Any failure</strong> in implementation, structure or understanding is totally my own and in no way reflects on the abilities and advice of those mentioned above who took the time to offer assistance.</p>

<p>Moving on. What we want to end up with is three applications:</p>

<table cellspacing="0">
  <thead>
    <tr>
      <th style="text-align:center;">Application</th>
      <th style="text-align:center;">Structure/Responsibility</th>
      <th style="text-align:center;">Talks to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Riak</td>
      <td>Bomb-proof data storage and replication.</td>
      <td style="text-align:center">-</td>
    </tr>
    <tr>
      <td>csd_core</td>
      <td>An OTP application that provides an API to a set of logic that deals with the transformation of data from a client through to the database. It should keep the clients ignorant of the data storage medium. It should provide business logic that would be required for any client application to be able to talk to a `csd`/Riak back-end.</td>
      <td style="text-align:center">Riak</td>
    </tr>
    <tr>
      <td>csd_web</td>
      <td>Provide a nice, web-based interface for the user to experience the goal of the Code Smackdown application.</td>
      <td style="text-align:center">csd_core</td>
    </tr>
  </tbody>
</table>

<p>Given that we&rsquo;re going to be using this structure, the &ldquo;root&rdquo; folder should actually be fairly clean without any source. Instead, each <code>csd</code>-related application should live in its own sub-folder under an <code>apps</code> folder and the root should just contain the means to build it and start it. In essence what we&rsquo;d like to see in the root folder is something like this:</p>

<pre><code>oj@spawn-link ~/blog/csd $ ls -F
apps/  dev.haproxy.conf  Makefile  proxy.sh*  rebar*  rebar.config  start.sh*
</code></pre>

<p>With that in mind, let&rsquo;s start the surgery.</p>

<h3 id="moving-csd-to-csd-web">Moving csd to csd_web</h3>

<p>There are two ways to approach this problem. The first is to do a <strong>find and replace</strong>, making sure you cover off file names as well as module names, etc. The second is to simply <strong>recreate the web site from scratch</strong>, copy over any missing files and make any other adjustments manually that may be required.</p>

<p>I preferred the second approach, so that&rsquo;s what I did. First I recreated the web application, which is now called <code>csd_web</code> in the <code>apps</code> folder:</p>

<pre><code>oj@spawn-link ~/blog/csd $ mkdir apps &amp;&amp; cd apps
oj@spawn-link ~/blog/csd/apps $ ~/blog/webmachine/scripts/new_webmachine.sh csd_web .
==&gt; priv (create)
Writing /home/oj/blog/csd/apps/csd_web/README
Writing /home/oj/blog/csd/apps/csd_web/Makefile
Writing /home/oj/blog/csd/apps/csd_web/rebar.config
Writing /home/oj/blog/csd/apps/csd_web/rebar
Writing /home/oj/blog/csd/apps/csd_web/start.sh
Writing /home/oj/blog/csd/apps/csd_web/ebin/csd_web.app
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web.erl
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web_app.erl
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web_sup.erl
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web_resource.erl
Writing /home/oj/blog/csd/apps/csd_web/priv/dispatch.conf
oj@spawn-link ~/blog/csd/apps $ ls -F
csd_web/
</code></pre>

<p>Next I removed a few files which weren&rsquo;t going to be needed any more. I then copied over <code>rebar.config</code>, the ErlyDTL templates and the <code>csd.app.src</code> file (which we need to modify):</p>

<pre><code>oj@spawn-link ~/blog/csd/apps $ cd csd_web
oj@spawn-link ~/blog/csd/apps/csd_web $ rm README rebar start.sh
oj@spawn-link ~/blog/csd/apps/csd_web $ cp ../../rebar.config .
oj@spawn-link ~/blog/csd/apps/csd_web $ cp -R ../../templates .
oj@spawn-link ~/blog/csd/apps/csd_web $ cp ../../src/csd.app.src ./src/csd_web.app.src
</code></pre>

<p>I then edited the <code>csd_web.app.src</code> file so that the names were updated (I tidied it up a little and added a version number too):</p>

<pre><code>%%-*- mode: erlang -*-
{application, csd_web,
  [
    {description, &quot;The Webmachine component of the Code Smackdown application.&quot;},
    {vsn, &quot;0.0.1&quot;},
    {modules, []},
    {registered, []},
    {applications,
      [
        kernel,
        stdlib,
        crypto,
        mochiweb,
        webmachine
      ]
    },
    {mod, {csd_web_app, []}},
    {env, []}
  ]
}.
</code></pre>

<p>I then opened up <code>csd_web_resource.erl</code> and made it look like the original <code>csd_resource.erl</code> so that it called the ErlyDTL template:</p>

<pre><code>-module(csd_web_resource).
-export([init/1, to_html/2]).

-include_lib(&quot;webmachine/include/webmachine.hrl&quot;).

init([]) -&gt;
  {ok, undefined}.

to_html(ReqData, State) -&gt;
  {ok, Content} = sample_dtl:render([{param, &quot;Slartibartfast&quot;}]),
  {Content, ReqData, State}.
</code></pre>

<p><code>csd_web</code> is now ready to go. To build it, we need to go back up to the root <code>csd</code> folder and adjust the <code>rebar.config</code> so that it knows to look in the <code>apps</code> sub-folder (thanks to <a href="http://twitter.com/andrewtj" title="AndrewTJ on Twitter">Andrew</a> for <a href="http://lists.basho.com/pipermail/rebar_lists.basho.com/2010-October/000246.html" title="Configuring the Rebar apps folder on Basho list">pointing this out</a>). We can also remove all the dependencies because that will be taken care of by <code>csd_web</code>:</p>

<pre><code>%%-*- mode: erlang -*-
{sub_dirs, [&quot;apps/csd_web&quot;]}.
</code></pre>

<p>Next, I removed all the other left-over stuff in the root folder that wasn&rsquo;t required any more (including the startup script):</p>

<pre><code>oj@spawn-link ~/blog/csd $ rm -rf README priv src templates start.sh
</code></pre>

<p>I then modify the <code>Makefile</code> so that it does a couple of other things:</p>

<ol>
<li>Includes a target which builds just the current applications <em>without</em> building the dependencies (this will make builds much quicker most of the time).</li>
<li>Includes a target which can start the web application, essentially replacing the original startup script. This target will be dependent on the previous target so that it is always up to date when running the application.</li>
<li>Includes targets which can start/stop <code>HAproxy</code>.</li>
</ol>

<pre><code>ERL ?= erl
APP = csd

.PHONY: deps

all: deps
  @./rebar compile

app:
  @./rebar compile skip_deps=true

deps:
  @./rebar get-deps

clean:
  @./rebar clean

distclean: clean
  @./rebar delete-deps

webstart: app
  exec erl -pa $(PWD)/apps/*/ebin -pa $(PWD)/deps/*/ebin -boot start_sasl -s reloader -s csd_web

proxystart:
  @haproxy -f dev.haproxy.conf
</code></pre>

<p>All that is left to do is start <code>haproxy</code> and launch the application (make sure <code>Riak</code> is running first). These commands need to be done in two different terminal windows. First, start the proxy (note the use of <code>sudo</code> so that we can listen on port 80):</p>

<pre><code>oj@spawn-link ~/blog/csd $ sudo make proxystart
[2] 1935
Available polling systems :
     sepoll : pref=400,  test result OK
      epoll : pref=300,  test result OK
       poll : pref=200,  test result OK
     select : pref=150,  test result OK
Total: 4 (4 usable), will use sepoll.
Using sepoll() as the polling mechanism.
</code></pre>

<p>Then make and start the web application. We have to do a full <code>make</code> first time around so that all the dependencies are resolved:</p>

<pre><code>oj@spawn-link ~/blog/csd $ make &amp;&amp; make webstart

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::21:04:18 ===
         application: csd_web
          started_at: nonode@nohost
</code></pre>

<p>Now we should be able to hit <a href="http://localhost/" title="localhost web app">localhost</a> and see the ErlyDTL template rendered in all its awesome, black-and-white glory:</p>

<p><img src="/uploads/2010/10/localhost-slartibartfast.png" /></p>

<p>Refactor complete. Now let&rsquo;s start work on our new OTP application which will be responsible for talking to Riak.</p>

<p>If you need a break, now is the time to take it! Go freshen up, take a leak and refill your glass.</p>

<p>Ready to go again? Here we go &hellip;</p>

<h3 id="creating-the-csd-core-otp-application">Creating the csd_core OTP Application</h3>

<p>Creation of an OTP-compliant application is another job for <a href="http://www.basho.com/developers.html#Rebar" title="Rebar">Rebar</a> as it comes with a set of templates built-in. Unfortunately those template aren&rsquo;t 100% and hence don&rsquo;t do everything we need to do out of the box. But we shall use them as a starting point:</p>

<pre><code>oj@spawn-link ~/blog/csd $ mkdir apps/csd_core &amp;&amp; cd apps/csd_core
oj@spawn-link ~/blog/csd/apps/csd_core $ ../../rebar create-app appid=csd_core
==&gt; csd_core (create-app)
Writing src/csd_core.app.src
Writing src/csd_core_app.erl
Writing src/csd_core_sup.erl
</code></pre>

<p>We have a very simple application shell set up, but we need to do a bit more work to get it ready. First, let&rsquo;s create our base <code>csd_core.erl</code> module which is used to fire up our application. For this we will use <code>csd_web.erl</code> (the one which is part of our Webmachine application) as a template. Note that I&rsquo;ve shuffled things around and removed some things that are not relevant:</p>

<pre><code>%% @author OJ Reeves &lt;oj@buffered.io&gt;
%% @copyright 2011 OJ Reeves

%% @doc csd_core startup code

-module(csd_core).
-author('OJ Reeves &lt;oj@buffered.io&gt;').
-export([start/0, start_link/0, stop/0]).

ensure_started(App) -&gt;
    case application:start(App) of
        ok -&gt;
            ok;
        {error, {already_started, App}} -&gt;
            ok
    end.

%% @spec start_link() -&gt; {ok,Pid::pid()}
%% @doc Starts the app for inclusion in a supervisor tree
start_link() -&gt;
    ensure_started(crypto),
    csd_core_sup:start_link().

%% @spec start() -&gt; ok
%% @doc Start the csd_core server.
start() -&gt;
    ensure_started(crypto),
    application:start(csd_core).

%% @spec stop() -&gt; ok
%% @doc Stop the csd_core server.
stop() -&gt;
    Res = application:stop(csd_core),
    application:stop(crypto),
    Res.
</code></pre>

<p>Next up, edit <code>csd_core.app.src</code> and add some application-specific information:</p>

<pre><code>
{application, csd_core,
  [
    {description, &quot;Core functionality for the Code Smackdown application.&quot;},
    {vsn, &quot;0.0.1&quot;},
    {registered, []},
    {applications,
      [
        kernel,
        stdlib
      ]
    },
    {mod, {csd_core_app, []}},
    {env, []}
  ]
}.
</code></pre>

<p>We know that we&rsquo;ll be talking to Riak, so we need to make sure we&rsquo;ve included the <code>riakc</code> (Riak client) dependency. Though I haven&rsquo;t yet talked about it, we&rsquo;ll also be using Mochiweb&rsquo;s <a href="https://github.com/mochi/mochiweb/blob/master/src/mochijson2.erl" title="Mochiweb's json module">mochijson2</a> module to help with handling JSON data, so we shall add this as a dependency to the application. Bear in mind this is already a dependency for the web component of the application, so we&rsquo;re not actually adding a <em>new</em> dependency to the overall application.</p>

<p>We can do this by creating a <code>rebar.config</code> in <code>apps/csd_core</code> and editing it to contain the following:</p>

<pre><code>%%-*- mode: erlang -*-
{deps,
  [
    {mochiweb, &quot;1.5.1&quot;, {git, &quot;git://github.com/mochi/mochiweb&quot;, {tag, &quot;1.5.1&quot;}}},
    {riakc, &quot;.*&quot;, {git, &quot;git://github.com/basho/riak-erlang-client&quot;, &quot;HEAD&quot;}}
  ]
}.
</code></pre>

<p>Then we need to tell <code>rebar</code> to build this new application by adjusting the <code>rebar.config</code> in the <code>csd</code> root folder:</p>

<pre><code>%%-*- mode: erlang -*-
{sub_dirs, [&quot;apps/csd_core&quot;, &quot;apps/csd_web&quot;]}.
</code></pre>

<p>Now we have enough to get the <code>csd_core</code> application started, even though it doesn&rsquo;t do anything. We just need to adjust our <code>Makefile</code> target so that it launches the <code>csd_core</code> application as well:</p>

<pre><code>ERL ?= erl
APP = csd

.PHONY: deps

all: deps
  @./rebar compile

app:
  @./rebar compile skip_deps=true

deps:
  @./rebar get-deps

clean:
  @./rebar clean

distclean: clean
  @./rebar delete-deps

webstart: app
  exec erl -pa $(PWD)/apps/\*/ebin -pa $(PWD)/deps/\*/ebin -boot start_sasl -s reloader -s csd_core -s csd_web

proxystart:
  @haproxy -f dev.haproxy.conf
</code></pre>

<p>Then off we go:</p>

<pre><code>oj@spawn-link ~/blog/csd $ make webstart
==&gt; csd_core (compile)
Compiled src/csd_core_app.erl
Compiled src/csd_core_sup.erl
Compiled src/csd_core.erl

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::21:49:27 ===
         application: csd_core
          started_at: nonode@nohost

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::21:49:27 ===
         application: csd_web
          started_at: nonode@nohost
</code></pre>

<p>As you can see we now have a system which contains both <code>csd_core</code> and <code>csd_web</code>. This is great, but <code>csd_core</code> needs a lot more work. The intent for this application is to be an <a href="http://en.wikipedia.org/wiki/Open_Telecom_Platform" title="Open Telecom Platform">OTP</a> application which provides an API to the <code>csd</code> logic and back-end database. This means we&rsquo;re going to need to get ourselves a <a href="http://www.erlang.org/doc/design_principles/gen_server_concepts.html" title="gen_server behaviour">gen_server</a> set up which can handle requests from various clients. Let&rsquo;s do that next.</p>

<p>Thankfully <code>rebar</code> comes with a simple template that we can use for creating the <code>gen_server</code> behaviour, so we can invoke that from the command line and have it generate the shell for us:</p>

<pre><code>oj@spawn-link ~/blog/csd/apps/csd_core $ ../../rebar create template=simplesrv srvid=csd_core_server
==&gt; csd_core (create)
Writing src/csd_core_server.erl
</code></pre>

<p>We now have a very dumb server ready to go, to make it start with the rest of the application we have to modify <code>csd_core_sup</code>, the <a href="http://www.erlang.org/doc/design_principles/sup_princ.html" title="supervisor behaviour">supervisor</a> and tell it to fire up the server for us:</p>

<pre><code>-module(csd_core_sup).

-behaviour(supervisor).

%% API
-export([start_link/0]).

%% Supervisor callbacks
-export([init/1]).

%% Helper macro for declaring children of supervisor
-define(CHILD(I, Type), {I, {I, start_link, []}, permanent, 5000, Type, [I]}).

%% ===================================================================
%% API functions
%% ===================================================================

start_link() -&gt;
  supervisor:start_link({local, ?MODULE}, ?MODULE, []).

%% ===================================================================
%% Supervisor callbacks
%% ===================================================================

init([]) -&gt;
  Server = ?CHILD(csd_core_server, worker),
  Processes = [Server],
  {ok, { {one_for_one, 5, 10}, Processes} }.
</code></pre>

<p>With this in place we can now start our application again and we should see the new <code>csd_core_server</code> appear in the start-up sequence:</p>

<pre><code>oj@spawn-link ~/blog/csd $ make webstart

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::22:04:04 ===
          supervisor: {local,csd_core_sup}
             started: [{pid,&lt;0.54.0&gt;},
                       {name,csd_core_server},
                       {mfargs,{csd_core_server,start_link,[]}},
                       {restart_type,permanent},
                       {shutdown,5000},
                       {child_type,worker}]

=PROGRESS REPORT==== 4-Apr-2011::22:04:04 ===
         application: csd_core
          started_at: nonode@nohost

   ... snip ...
</code></pre>

<p>The shell and structure of our application is now in place. We are finally ready to start talking to Riak!</p>

<p>Again, now is the time to have a mini-break if you need one. Grab a <em>Shigar und a waffle</em> and a cup of English Breakfast tea.</p>

<h2 id="preparing-csd-core-for-riak-connectivity">Preparing csd_core for Riak connectivity</h2>

<p>Given that this is the first look at connecting to Riak, we&rsquo;re going to have to set up a little infrastructure to support our needs. As a result, the data itself won&rsquo;t be discussed much for fear of turning this post into something way more epic than originally intended.</p>

<p>So in short, we&rsquo;re interested in storing the idea of a <em>code snippet</em>. That is an entity which contains two opposing blobs of code which are being compared. That snippet will have a title. Down the track, more information will be associated with this snippet, such as the author, along with links to a set of comments and votes. For now we&rsquo;ll just focus on storing the bare essentials of the snippet.</p>

<h3 id="the-snippet">The Snippet</h3>

<p>As far as our Erlang code is concerned, our snippet is going to be a simple list of properties that we can interact with via the <a href="http://www.erlang.org/doc/man/proplists.html" title="proplists">proplists</a> module. This keeps things really simple. To demonstrate what our snippet will look like in code, here is the function that takes a Title, and the two code blobs (called Left and Right) and returns a <code>snippet</code> instance. This code goes in a module called <code>csd_snippet</code> defined in <code>src/csd_snippet.erl</code>:</p>

<pre><code>to_snippet(Title, Left, Right) -&gt;
  {snippet,
    [
      {title, Title},
      {left, Left},
      {right, Right}
    ]
  }.
</code></pre>

<p>Note that the first part of the tuple is the atom <code>snippet</code> which I am using to identify the layout of the contents in the second part of the tuple. Down the track we&rsquo;ll have more collections of data in the system than just snippets, and we may want to make sure that the caller doesn&rsquo;t accidentally pass in a <code>user</code>, for example, to a function expecting a <code>snippet</code>.</p>

<p>It is important at this point to note that, down the track, I will include a <code>key</code> property in all of the data objects that are pushed to Riak. This property serves as the identifier for the object in Riak and is stored alongside the rest of the data so that it is easy to relate the in-memory instance back to the stored instance. This value, if not specified, will be inserted automatically when an item is saved via the API functions in <code>csd_core</code>. More on this later.</p>

<h3 id="formatting-data-for-storage-in-riak">Formatting Data for Storage in Riak</h3>

<p>Riak is very flexible in that it will store whatever kind of information you give it. This is good because it means we can cater our data format to whatever needs we have.</p>

<p>In our case, the <em>easiest</em> option would be to store our Erlang terms as binary using <a href="http://www.erlang.org/doc/man/erlang.html#term_to_binary-1" title="term_to_binary">term_to_binary</a> as we wouldn&rsquo;t have to think about <em>anything</em> else. We could easily read the data using <a href="http://www.erlang.org/doc/man/erlang.html#binary_to_term-1" title="binary_to_term">binary_to_term</a>. Done.</p>

<p>This comes with a set of problems though. For example, if we wanted to <a href="http://en.wikipedia.org/wiki/MapReduce" title="map/reduce">map/reduce</a> using JavaScript we wouldn&rsquo;t find it easy to get the data into a format that we could use. Another example would be that the RESTful interface to Riak would be close to useless because <strong>any</strong> non-Erlang client would have to somehow get the data into a meaningful format to work with.</p>

<p>Instead of using binary and throwing Erlang terms straight into Riak, we&rsquo;re going to use <a href="http://json.org/" title="JavaScript Object Notation">JSON</a>. It&rsquo;s very easy to convert to and from JSON in many different languages, and it&rsquo;s very easy to read. We can also easily verify that the data is being stored correctly by querying Riak&rsquo;s RESTful interface directly using <a href="http://curl.haxx.se/" title="cURL homepage">cURL</a> or a browser.</p>

<p>In order to store data in JSON format, we&rsquo;re going to enlist the help of <a href="https://github.com/mochi/mochiweb/blob/master/src/mochijson2.erl" title="Mochiweb's json module">mochijson2</a>, a library that comes with <a href="https://github.com/mochi/mochiweb" title="Mochiweb">Mochiweb</a> that makes it a <em>lot</em> easier to deal with JSON than doing everything manually. Given that we&rsquo;re using Webmachine for the front-end (which itself relies on Mochiweb) we already have the dependency available.</p>

<p>Unfortunately we can&rsquo;t just throw our data straight at this module and have it do everything for us. <code>mochijson2</code> requires data to be in a certain format before it can encode it to JSON. When decoding <em>from</em> JSON, it converts the data into the same format. Hence, we need the ability to convert our own data format to and from this intermediate data format so that <code>mochijson2</code> can deal with it.</p>

<p>We need two functions: <code>to_json()</code> and <code>from_json()</code>, and we shall define these in a helper module called <code>csd_json</code>. This module will live in <code>csd_core</code>:</p>

<pre><code>-module(csd_json).
-export([from_json/1, from_json/2, to_json/1, to_json/2]).

to_json(PropList) -&gt;
  to_json(PropList, fun(_) -&gt; true end).

to_json(PropList, IsStrFun) -&gt;
  list_to_binary(mochijson2:encode(from_proplist(PropList, IsStrFun))).

from_json(Json) -&gt;
  from_json(Json, fun(_) -&gt; true end).

from_json(Json, IsStrFun) -&gt;
  to_proplist(mochijson2:decode(Json), IsStrFun).
</code></pre>

<p>You&rsquo;re probably wondering why each of these functions requires the <code>IsStrFun</code> parameter (if you&rsquo;re not, you&rsquo;re obviously an experienced Erlanger!). For those who don&rsquo;t know, strings in Erlang are actually lists of integers. This is fantastic as it makes it easy to manipulate strings as if they were lists, but it comes at a small price: it&rsquo;s not possible to determine the difference between a list of integers and a string.</p>

<p>Why is this important? <code>mochijson2</code> needs strings to be encoded as binaries, so we need a way to differentiate between integer lists and real strings. My original implementations of both the <code>to_json()</code> and <code>from_json()</code> functions attempted to figure out if certain fields were strings or not by looking at the content of the list. Not only was the code messy, but it wasn&rsquo;t foolproof. Instead, I made the decision to force the user to provide a callback function which will tell the JSON serialiser if the given property is a string or not. This callback takes a single parameter which is the name (in atom form) of the property and returns a boolean &ndash; <code>true</code> indicates that the value is a string, <code>false</code> otherwise.</p>

<p>In some cases we might just be happy to encode/decode every single value as a string. Hence, there is an overload to both <code>to_json()</code> and <code>from_json()</code> which caters for this case. The rest of the code which implments the conversion is listed below. Don&rsquo;t feel that you need to understand the code below, as it&rsquo;s really not the goal of this post. The full source to this module is included in the source link specified at the end of this post.</p>

<pre><code>from_proplist(List=[H|_], IsStrFun) when is_tuple(H) -&gt;
  { struct, lists:map(fun(P) -&gt; from_proplist(P, IsStrFun) end, List) };
from_proplist({PropName, ComplexProp=[H|_]}, IsStrFun) when is_tuple(H) -&gt;
  { list_to_binary(atom_to_list(PropName)), from_proplist(ComplexProp, IsStrFun) };
from_proplist({PropName, PropVal}, IsStrFun) -&gt;
  { list_to_binary(atom_to_list(PropName)), to_value(PropName, PropVal, IsStrFun) }.

to_proplist({struct, PropList}, IsStrFun) when is_list(PropList) -&gt;
  lists:map(fun(P) -&gt; to_proplist(P, IsStrFun) end, PropList);
to_proplist({PropName, ComplexProp={struct, _}}, IsStrFun) -&gt;
  { list_to_atom(binary_to_list(PropName)), to_proplist(ComplexProp, IsStrFun) };
to_proplist({PropName, PropVal}, IsStrFun) -&gt;
  PropAtom = list_to_atom(binary_to_list(PropName)),
  { PropAtom, from_value(PropAtom, PropVal, IsStrFun) }.

to_value(PropName, L=[H|_], IsStrFun) when is_list(L) and is_list(H) -&gt;
  lists:map(fun(P) -&gt; to_value(PropName, P, IsStrFun) end, L);
to_value(PropName, L, IsStrFun) when is_list(L) -&gt;
  case IsStrFun(PropName) of
    true -&gt; list_to_binary(L);
    _ -&gt; lists:map(fun(V) -&gt; to_value(PropName, V, IsStrFun) end, L)
  end;
to_value(_, V, _) -&gt;
  V.

from_value(PropName, L, IsStrFun) when is_list(L) -&gt;
  lists:map(fun(P) -&gt; from_value(PropName, P, IsStrFun) end, L);
from_value(PropName, B, IsStrFun) when is_binary(B) -&gt;
  case IsStrFun(PropName) of
    true -&gt; binary_to_list(B);
    _ -&gt; B
  end;
from_value(_, V, _) -&gt;
  V.
</code></pre>

<p>We are now able to read and write data to and from JSON format. Now we need to use the Riak client to push that into our Riak cluster.</p>

<h3 id="setting-up-the-riak-client">Setting up the Riak client</h3>

<p>Basho have done a great job of creating a protocol buffer-based client for use with Riak. The interface is really simple to use. Despite that, we shall create a module which will deal with this for us. This gives us a single point of abstraction of Riak and a place where we can add extra support for our own needs without spreading Riak-specific code all over the source base.</p>

<p>The first problem we need to resolve is: <em>what do we do with configuration?</em></p>

<p>This was a question I initially didn&rsquo;t know how to answer. After a bit of deliberation and a chat with a <a href="http://twitter.com/mononcqc" title="Ferd T-H on Twitter">respected Erlang sifu</a> (who has a <a href="http://learnyousomeerlang.com/" title="Learng you some erlang">fantastic Erlang tutorial site</a>) I decided to go with a module-based option.</p>

<p>We have our Riak cluster hidden behind the <code>haproxy</code> load balancer, and hence we have a single entry-point to connect to. If this entry-point changes, it changes for all of the clients, not just a single client. Therefore, I want the ability to manage a single set of connection information, but I want the ability to update it on the fly without having to restart the <code>csd_core</code> application. This is Erlang, after all, and modifying code and configuration on-the-fly is extremely easy. We shall abuse that.</p>

<p>We create a single module, <code>csd_riak_config.erl</code>, to contain our configuration which is referenced at start-up. It looks like this:</p>

<pre><code>-module(csd_riak_config).
-export([connection_info/0]).

connection_info() -&gt;
  { &quot;127.0.0.1&quot;, 8080 }.
</code></pre>

<p>Pretty simple stuff. Let&rsquo;s use this functionality in our <code>gen_server</code>, and carry the configuration through from initialisation to all of the calls that will be made to the Riak server. This requires two simple modifications to the <code>csd_core_server</code> module:</p>

<pre><code>start_link() -&gt;
  ConnInfo = csd_riak_config:connection_info(),
  gen_server:start_link({local, ?SERVER}, ?MODULE, [ConnInfo], []).

% ...

init([ConnInfo]) -&gt;
  {ok, ConnInfo}.
</code></pre>

<p>Confiuration is now loaded and is being passed to all of our <code>gen_server</code> callbacks. Let&rsquo;s make use of it. <code>csd_snippet</code> is the entry point for all snippet-related information, and one of the things that we are going to want to be able to do is write a snippet to Riak. So let&rsquo;s create a code-path that can do that.</p>

<h4 id="writing-data-to-riak">Writing Data to Riak</h4>

<p>The first point of call for a client is the OTP interface. Let&rsquo;s create an API call and a call handler to support saving snippets in <code>csd_core_server</code>:</p>

<pre><code>
%% This is a simple function which invokes a call via the gen_sever
%% behaviour.
save_snippet(Snippet) -&gt;
  gen_server:call(?SERVER, {save_snippet, Snippet}, infinity).

%% Handle the case where a caller wants to save a snippet to Riak. We
%% create a connection to Riak and pass that into the snippet handler
%% along with the snippet that needs to be saved. We return the newly
%% saved snippet.
handle_call({save_snippet, Snippet}, _From, ConnInfo) -&gt;
  RiakPid = csd_riak:connect(ConnInfo),
  SavedSnippet = csd_snippet:save(RiakPid, Snippet),
  {reply, SavedSnippet, ConnInfo};
</code></pre>

<p>Of course, we will need to export the <code>save_snippet()</code> function if we want to be able to call it.</p>

<p>You&rsquo;ll notice that we&rsquo;re getting the connection information passed in as the state for the OTP call, and that we&rsquo;re using that to create a connection to Riak via the <code>csd_riak</code> module. We shall cover this module in just a minute, but hopefully the interface to this function should make it relatively self-explanatory.</p>

<p>You might be wondering &ldquo;Why are you creating the Riak client connection here instead of letting the <code>csd_snippet:save()</code> function do it by itself. It&rsquo;s a good question. The reason I decided to create the connection as part of OTP call rather than in the data/helper modules is because down the track there will probably be a need to do multiple interactions with Riak in a single call. If we force each of the called modules, such as <code>csd_snippet</code>, to establish their own connections then we&rsquo;d probably have <em>multiple connections to Riak being created during a single client request</em>. This isn&rsquo;t what I would like to see happen, so it made sense (in my view) to create the client connection once and reuse it across all modules that are invoked during the request.</p>

<p>With that out of the way, we need to implement the <code>save()</code> function in the <code>csd_snippet</code> module. Brace yourself:</p>

<p><span class="filename"></span></p>

<pre><code>save(RiakPid, Snippet={snippet, SnippetData}) -&gt;
  case proplists:get_value(key, SnippetData, undefined) of
    undefined -&gt;
      Key = csd_riak:new_key(),
      NewSnippetData = [{key, Key} | SnippetData],
      RiakObj = csd_riak:create(?BUCKET, Key, to_json_internal(NewSnippetData)),
      ok = csd_riak:save(RiakPid, RiakObj),
      {snippet, NewSnippetData};
    ExistingKey -&gt;
      RiakObj = csd_riak:fetch(RiakPid, ?BUCKET, ExistingKey),
      NewRiakObj = csd_riak:update(RiakObj, to_json_internal(SnippetData)),
      ok = csd_riak:save(RiakPid, NewRiakObj),
      Snippet
  end.
</code></pre>

<p>On the surface this looks a little complicated, but it&rsquo;s actually very simple. As mentioned earlier in the post, we use a <code>key</code> property to store the identifier of the object in Riak. This code supports this notion. It works as follows:</p>

<ol>
<li><strong>Try to get the value of the <code>key</code> from the given list of properties.</strong></li>
<li><strong>If <em>not</em> found &hellip;</strong>

<ol>
<li>create a new key using the <code>new_key()</code> function in the <code>csd_riak</code> module (this will be covered shortly).</li>
<li>Add the <code>key</code> to the list of properties for the snippet.</li>
<li>Create a new instance of a Riak object (more on this later) which contains the details of the snippet data to be written, along with the target bucket name and the key of the snippet.</li>
<li>Save the Riak object to the Riak cluster using the specified Riak client connection (Pid), and for now assume that it succeeds.</li>
<li>Return the new set of snippet data with the snippet&rsquo;s key included.</li>
</ol></li>
<li><strong>If found &hellip;</strong>

<ol>
<li>Load the existing data from the Riak cluster into a Riak object.</li>
<li>Update the Riak object with the new data values passed into the function.</li>
<li>Save the Riak object <em>back</em> to the Riak cluster using the specified Riak client connection (Pid), and for now assume that it succeeds.</li>
<li>Return the snippet back to the caller as is.</li>
</ol></li>
</ol>

<p>It&rsquo;s fairly basic functionality which does enough to cater for our needs at this point. Through this one function, we can write new snippet instances to Riak, and we can update them too.</p>

<p>You&rsquo;ll also notice that another function is being called that hasn&rsquo;t been discussed: <code>to_snippet_internal()</code>. Rather than try to explain this, let&rsquo;s see the code as it&rsquo;s quite easy to follow:</p>

<pre><code>%% exported functions
to_json({snippet, SnippetData}) -&gt;
  to_json_internal(SnippetData).

from_json(SnippetJson) -&gt;
  from_json_internal(SnippetJson).

%% helper functions used internally.
to_json_internal(SnippetData) -&gt;
  csd_json:to_json(SnippetData, fun is_string/1).

from_json_internal(SnippetJson) -&gt;
  {snippet, csd_json:from_json(SnippetJson, fun is_string/1)}.

is_string(title) -&gt; true;
is_string(left) -&gt; true;
is_string(right) -&gt; true;
is_string(_) -&gt; false.
</code></pre>

<p>As you can see, these are helper functions which call the <code>csd_json</code> functions to serialise/deserialise to/from JSON format. The <code>is_string()</code> function is the one that is used to tell the JSON functionality which properties are strings and which are not. At the moment, all properties defined on the snippet are string properties. Bear in mind that the <code>key</code> property, which is added automatically, is <em>not</em> a string.</p>

<p>All that is left is to see how <code>csd_riak</code> deals with the underlying Riak connectivity. Prepare to be underwhelmed!</p>

<pre><code>%% @spec connect(connection_info()) -&gt; pid()
%% @doc Create a connection to the specified Riak cluster and
%%      return the Pid associated with the new connection.
connect({IP, Port}) -&gt;
  {ok, RiakPid} = riakc_pb_socket:start_link(IP, Port),
  RiakPid.

%% @spec create(binary, binary, json) -&gt; riakc_obj()
%% @doc Create a new instance of a riak object using the
%%      parameters given. The riak object can then be
%%      persisted to a Riak node/cluster. This overload
%%      assumes that the data passed in is JSON and sets
%%      the MIME type to &quot;application/json&quot; for you.
create(Bucket, Key, JsonData) -&gt;
  create(Bucket, Key, JsonData, &quot;application/json&quot;).

%% @spec create(binary, binary, term(), string) -&gt; riakc_obj()
%% @doc Create a new instance of a riak object using the
%%      parameters given. The riak object can then be
%%      persisted to a Riak node/cluster. This overload
%%      takes arbitrary data and requires the user to
%%      specify the mime type of the data that is being
%%      stored.
create(Bucket, Key, Item, MimeType) -&gt;
  RiakObj = riakc_obj:new(Bucket, Key, Item, MimeType),
  RiakObj.

%% @spec fetch(pid(), binary, binary) -&gt; riakc_obj()
%% @doc Fetches a riakc object from a Riak node/cluster
%%      using the connection given.
fetch(RiakPid, Bucket, Key) -&gt;
  RiakObj = riakc_pb_socket:get(RiakPid, Bucket, Key),
  RiakObj.

%% @spec update(riakc_obj(), term()) -&gt; riakc_obj()
%% @doc Updates the stored value for a riakc object with
%%      the new one specified.
update(RiakObj, NewValue) -&gt;
  NewRiakObj = riakc_obj:update_value(RiakObj, NewValue),
  NewRiakObj.

%% @spec get_value(riakc_obj()) -&gt; term()
%% @doc Retrieves the stored value from within the riakc
%%      object.
get_value(RiakObj) -&gt;
  Value = riakc_obj:get_value(RiakObj),
  Value.

%% @spec save(pid(), riakc_obj()) -&gt; {ok, riakc_obj()} | {error | Reason}
%% @doc Saves the given riak object to the specified Riak node/cluster.
save(RiakPid, RiakObj) -&gt;
  Result = riakc_pb_socket:put(RiakPid, RiakObj),
  Result.

%% @spec new_key() -&gt; key()
%% @doc Generate an close-to-unique key that can be used to identify
%%      an object in riak. This implementation is blatantly borrowed
%%      (purloined) from the wriaki source (thanks basho!)
new_key() -&gt;
  { {Yr, Mo, Dy}, {Hr, Mn, Sc} } = erlang:universaltime(),
  {_, _, Now} = now(),
  new_key([Yr, Mo, Dy, Hr, Mn, Sc, node(), Now]).

%% @spec new_key(list()) -&gt; key()
%% @doc Generate an close-to-unique key that can be used to identify
%%      an object in riak using the given list parameter as the stuff
%%      to hash.
new_key(List) -&gt;
  Hash = erlang:phash2(List),
  base64:encode(&lt;&lt;Hash:32&gt;&gt;).
</code></pre>

<p>Hopefully the code in this module is fairly self-explanatory. It&rsquo;s a very simple API to follow which made it very easy to build. So with this in place, let&rsquo;s fire up the application, create a new snippet and see if it lands in the Riak store:</p>

<pre><code>oj@spawn-link  ~/blog/csd $ make webstart

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::22:54:55 ===
         application: csd_web
          started_at: nonode@nohost

1&gt; Snippet = csd_snippet:to_snippet(
1&gt; &quot;Super composition!&quot;,
1&gt; &quot;(.^) = (.) . (.)&quot;,
1&gt; &quot;(.^) = fmap `fmap` fmap&quot;).
{snippet,[{title,&quot;Super composition!&quot;},
          {left,&quot;(.^) = (.) . (.)&quot;},
          {right,&quot;(.^) = fmap `fmap` fmap&quot;}]}
2&gt; SavedSnippet = csd_core_server:save_snippet(Snippet).

PROGRESS REPORT==== 4-Apr-2011::22:57:13 ===
          supervisor: {local,inet_gethost_native_sup}
             started: [{pid,&lt;0.103.0&gt;},{mfa,{inet_gethost_native,init,[[]]}}]

=PROGRESS REPORT==== 4-Apr-2011::22:57:13 ===
          supervisor: {local,kernel_safe_sup}
             started: [{pid,&lt;0.102.0&gt;},
                       {name,inet_gethost_native_sup},
                       {mfargs,{inet_gethost_native,start_link,[]}},
                       {restart_type,temporary},
                       {shutdown,1000},
                       {child_type,worker}]
{snippet,[{key,&lt;&lt;&quot;B41kUQ==&quot;&gt;&gt;},
          {title,&quot;Super composition!&quot;},
          {left,&quot;(.^) = (.) . (.)&quot;},
          {right,&quot;(.^) = fmap `fmap` fmap&quot;}]}
</code></pre>

<p>As you can see from the above script dump, a new <code>key</code> was generated for us and stored alongside the snippet (it&rsquo;s highlighted in bold). Verifying that the data has persisted is simple. We can hit any of the Riak nodes via its web interface. Let&rsquo;s take a look at <strong><a href="http://localhost:8091/riak/snippet/B41kUQ==">http://localhost:8091/riak/snippet/B41kUQ==</a></strong> (your URL will have a different key):</p>

<p><img src="/uploads/2010/10/localhost-verify-write.png" /></p>

<p>Great stuff! For more detail, let&rsquo;s see what cURL has to say:</p>

<pre><code>oj@spawn-link ~/blog/csd/ $ curl http://localhost:8091/riak/snippet/B41kUQ== -v
* About to connect() to localhost port 8091 (#0)
*   Trying ::1... Connection refused
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8091 (#0)
&gt; GET /riak/snippet/B41kUQ== HTTP/1.1
&gt; User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
&gt; Host: localhost:8091
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; X-Riak-Vclock: a85hYGBgzGDKBVIsjOy7jmcwJTLmsTJ8tuc7zpcFAA==
&lt; Vary: Accept-Encoding
&lt; Server: MochiWeb/1.1 WebMachine/1.7.3 (participate in the frantic)
&lt; Link: &lt;/riak/snippet&gt;; rel=&quot;up&quot;
&lt; Last-Modified: Mon, 04 Apr 2011 13:13:23 GMT
&lt; ETag: &quot;6fw7c5v4IPAsf4B5hMHybc&quot;
&lt; Date: Mon, 04 Apr 2011 13:13:36 GMT
&lt; Content-Type: application/json
&lt; Content-Length: 107
&lt; 
* Connection #0 to host localhost left intact
* Closing connection #0
{&quot;key&quot;:&quot;B41kUQ==&quot;,&quot;title&quot;:&quot;Super composition!&quot;,&quot;left&quot;:&quot;(.^) = (.) . (.)&quot;,&quot;right&quot;:&quot;(.^) = fmap `fmap` fmap&quot;}
</code></pre>

<p>As you can see, it has not only serialised to JSON properly, but the MIME type has been set correctly as well.</p>

<p>This is all well and good, but we need our code to be able to read from Riak as well. That&rsquo;s up next.</p>

<h4 id="reading-data-from-riak">Reading Data from Riak</h4>

<p>We&rsquo;ve already covered off what happens at the bottom level when reading data from Riak (see the above code snippet for more info). To enable this functionality at the top level, we simply need to create a <code>gen_server</code> call, handle it appropriately and expose a function in the <code>csd_snippet</code> module. Let&rsquo;s start at the top level:</p>

<pre><code>%% OTP API function to get a snippet based on the key
get_snippet(SnippetKey) -&gt;
  gen_server:call(?SERVER, {get_snippet, SnippetKey}, infinity).

%% handle the call and call the functionality from csd_snippet
handle_call({get_snippet, SnippetKey}, _From, ConnInfo) -&gt;
  RiakPid = csd_riak:connect(ConnInfo),
  Snippet = csd_snippet:fetch(RiakPid, SnippetKey),
  {reply, Snippet, ConnInfo};
</code></pre>

<p>This code is a bit of a no-brainer. It&rsquo;s very similar to the writing code, but just a bit simpler. Let&rsquo;s see what the <code>csd_snippet:fetch()</code> function looks like:</p>

<pre><code>fetch(RiakPid, Key) -&gt;
  {ok, RiakObj} = csd_riak:fetch(RiakPid, ?BUCKET, Key),
  SnippetJson = csd_riak:get_value(RiakObj),
  from_json_internal(SnippetJson).
</code></pre>

<p>This code just pulls a Riak object out of the back-end, extracts is value and deserialises it from JSON to our Erlang <code>proplist</code>. Very simple stuff.</p>

<p>We should be able to build this and, via the Erlang console, verify that it functions:</p>

<pre><code>3&gt; Reloading csd_core_server ... ok.
3&gt; csd_core_server:get_snippet(&lt;&lt;&quot;B41kUQ==&quot;&gt;&gt;).
{snippet,[{key,&lt;&lt;&quot;B41kUQ==&quot;&gt;&gt;},
          {title,&quot;Super composition!&quot;},
          {left,&quot;(.^) = (.) . (.)&quot;},
          {right,&quot;(.^) = fmap `fmap` fmap&quot;}]}
</code></pre>

<p>Works like a charm. Now, for the icing on the cake, let&rsquo;s get this rendering in a very simple template in our browser.</p>

<h3 id="end-to-end">End to End</h3>

<p>In order to gain access to our data in Riak from the web we need to create a new resource. This resource will respond to any URI of the form <code>/snippet/&lt;key&gt;</code>. We shall call this resource <code>csd_web_snippet_resource</code> and we&rsquo;ll be putting this in our web application. It looks like this:</p>

<pre><code>%% @author OJ Reeves &lt;oj@buffered.io&gt;
%% @copyright 2010 OJ Reeves
%% @doc Webmachine resource that handles snippet-related actions

-module(csd_web_snippet_resource).
-author('OJ Reeves &lt;oj@buffered.io&gt;').

-export([init/1, to_html/2]).

-include_lib(&quot;webmachine/include/webmachine.hrl&quot;).

init([]) -&gt; {ok, undefined}.

to_html(ReqData, State) -&gt;
  PathInfo = wrq:path_info(ReqData),
  {ok, SnippetKey} = dict:find(key, PathInfo),
  {snippet, SnippetData} = csd_core_server:get_snippet(list_to_binary(SnippetKey)),
  {ok, Content} = snippet_dtl:render(SnippetData),
  {Content, ReqData, State}.
</code></pre>

<p>As you can see, this code calls through to the <code>csd_core_server</code> to extract the data from the back-end. The value that is used as a key for the snippet is one that is pulled from the URI via Webmachine&rsquo;s <code>wrq:path_info()</code> function. This function extracts values from the URI based on the rules in <code>dispatch.conf</code> and provides a <a href="http://www.erlang.org/doc/man/dict.html" title="Erlang dict">dict</a> which can be used to lookup the values.</p>

<p>The code also uses a new ErlyDTL template called <code>snippet</code>. We&rsquo;d best add that to the <code>templates</code> folder:</p>

<pre><code>&lt;!-- TODO : get the templating engine to stop ripping out the inline template code --&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Snippet View&lt;/h1&gt;
    &lt;h2&gt;{{ &quot;{{ title &quot;}} }}&lt;/h2&gt;
    &lt;p&gt;Left: {{ &quot;{{ left &quot;}} }}&lt;/p&gt;
    &lt;p&gt;Right: {{ &quot;{{ right &quot;}} }}&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Finally, we just need to adjust <code>dispatch.conf</code> to include the new route handler so that our code gets called:</p>

<pre><code>%%-*- mode: erlang -*-
{[], csd_web_resource, []}.
{[&quot;snippet&quot;, key], csd_web_snippet_resource, []}.
</code></pre>

<p>Note how <code>key</code> is specified alongside <code>&quot;snippet&quot;</code>. This means that the path following <code>snippet/</code> in the URI will be associated with the <code>key</code> atom in the <code>dict</code> generated by <code>wrq:path_info()</code>.</p>

<p>We&rsquo;re ready to rock. Rebuild, then hit the right URL, <strong><a href="http://localhost/snippet/B41kUQ==">http://localhost/snippet/B41kUQ==</a></strong> (again, your key will be different), and you should get the following:</p>

<p><img src="/uploads/2010/10/webmachine-to-riak.png" /></p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Thanks for sticking with me! As you can see there is a little bit of ground-work required if you&rsquo;re interested in producing some form of structure that you can reuse all over your application, but the effort is definitely worth it. Now we have something in place which we can use to store arbitrarily complex <code>proplists</code> into Riak in JSON format, we have the ability to talk to Riak (read and write), and we have a proper application structure in place which we can build on.</p>

<p>Please note that the mechanism implemented in this post is quite simple and doesn&rsquo;t cover all cases that will be required before the application is complete. In future posts, this implementation will change to support more of those cases, such as dealing with concurrent updates, handling versions, etc.</p>

<p>Many thanks to those people who took the time out of their busy schedules to review my post before I shared it with the world. Those people shall remain nameless to protect them from any mistakes made in this post (which are solely my own).</p>

<p>As always, comments and feedback is welcomed and greatly appreciated. As are suggestions on improvements, pitfalls and blatant mistakes :)</p>

<p><strong>Note:</strong> The code for Part 3 (this post) can be found on <a href="https://github.com/OJ/csd/tree/Part3-20110405" title="Source code for Part 3">Github</a>.</p>

<p>Other parts in this series: <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a>, <a href="/posts/webmachine-erlydtl-and-riak-part-2/" title="Webmachine, ErlyDTL and Riak - Part 2">Part 2</a>, <a href="/posts/webmachine-erlydtl-and-riak-part-4/" title="Webmachine, ErlyDTL and Riak - Part 4">Part 4</a>, <a href="/posts/webmachine-erlydtl-and-riak-part-5/" title="Webmachine, ErlyDTL and Riak - Part 5">Part 5</a></p>

	  
	  	  <div class="tags">	
	    <p class="categories">
	  
	  <a class="btn btn-default btn-xs text-capitalize" href="/categories/riak">Riak</a>
	  
	  <a class="btn btn-default btn-xs text-capitalize" href="/categories/databases">Databases</a>
	  
	  <a class="btn btn-default btn-xs text-capitalize" href="/categories/functional-programming">Functional Programming</a>
	  
	  <a class="btn btn-default btn-xs text-capitalize" href="/categories/howto">HOWTO</a>
	  
	  <a class="btn btn-default btn-xs text-capitalize" href="/categories/erlang">Erlang</a>
	  
	  <a class="btn btn-default btn-xs text-capitalize" href="/categories/webmachine">Webmachine</a>
	  
	    </p>
	    
<p><a itemprop="keywords" class=" label label-danger" href="/tags/erlang">Erlang</a> <a itemprop="keywords" class=" label label-danger" href="/tags/erlydtl">ErlyDTL</a> <a itemprop="keywords" class=" label label-danger" href="/tags/haproxy">HAProxy</a> <a itemprop="keywords" class=" label label-danger" href="/tags/nosql">NoSQL</a> <a itemprop="keywords" class=" label label-danger" href="/tags/riak">Riak</a> <a itemprop="keywords" class=" label label-danger" href="/tags/webmachine">Webmachine</a> <a itemprop="keywords" class=" label label-danger" href="/tags/web-development">web development</a></p>



	    	  </div>
	    


<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ojsrants" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
      </div></article>


	 </div>

	 </div>
       </div>
     </div>

 <div class="container footer">
  <div class="row">
    <div class="col-md-10">
      <small class="text-muted">Copyright OJ Reeves 2019 Theme:<a href="https://feiio.com/">eiio</a></small>
    </div>
    <div class="col-md-2">
      <small class="text-muted">Trying to make the Internet less shit, one bit at a time.</small>
      </div>
   </div>
 </div>
</body></html>
